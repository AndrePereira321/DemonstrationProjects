package tableGenerator

import (
	"crypto/sha256"
	"fmt"
	"math/rand"
	"os"
	"sort"
	"strconv"
	"sync"
)

//Represents a line to write into file.
type line struct {
	head string
	tail string
}

const charSet = "azertyuiopqsdfghjklmwxcvbnAZERTYUIOPQSDFGHJKLMWXCVBN1234567890"

//Number of routines to generate chains
const maxRoutines = 30

//Number of chains generated by each routine
const buffSize = 100000

//Size of the password
//Can be modified (MAX = 8)
const pwSize = 6

//Null terminator
const endToken = "\x00"

//Line feed
const endLine = "\x00\n"

//Allows to wait for the chains generations routines.
var wg sync.WaitGroup

//Global vars to avoid many arguments in functions.
var (
	tableFolder string
	chainLength int
)

//Main public function that generates the rainbow table with the given arguments.
//It will generate a 'buffSize' of lines in 'maxRoutines' threads. When
//all the threads are over it will launch another thread to sort and write
//the data in the 'fileNumber' file inside the folder.
func GenerateTable(tableFold string, chainSize, linesQt int) {
	var lineCount, fileNumber, nbRoutines int
	//Channel used by - Producer: makeChains |Â Consummer: receiveData
	data := make(chan line, buffSize*maxRoutines)
	tableFolder = tableFold
	chainLength = chainSize
	lineCount = 0
	fileNumber = 1
	for lineCount < linesQt {
		nbRoutines = 0
		fmt.Println("Processing Data...")
		for nbRoutines < maxRoutines && lineCount < linesQt {
			go makeChains(data)
			lineCount += buffSize
			nbRoutines++
		}
		buff := receiveData(nbRoutines, data)
		wg.Add(1)
		go writeData(fileNumber, buff)
		fileNumber++
	}
	wg.Wait() //Avoid ending program with writing routines in execution
	fmt.Println("Completed!")
}

//Creates a 'buffSize' number of chains (lines)
//and sends the results to the given channel.
func makeChains(lines chan line) {
	var i, j, col int
	var hash [32]byte
	var pw []byte
	for i = 0; i < buffSize; i++ {
		var curLine line
		pw = randomPassWord()
		curLine.head = string(pw)
		for col = 0; col < chainLength; col++ {
			hash = sha256.Sum256(pw)
			for j = 0; j < pwSize; j++ {
				pw[j] = charSet[hash[(j+col)%32]%62]
			}
		}
		curLine.tail = string(pw)
		lines <- curLine
	}
}

//Receives the lines generated by makeChain and put them into a buffer.
func receiveData(nbRoutines int, data chan line) []line {
	buff := make([]line, nbRoutines*buffSize)
	for i := 0; i < nbRoutines*buffSize; i++ {
		buff[i] = <-data
	}
	return buff
}

//Sorts the given 'buff' and writes each line
//of that buffer into the file 'fileNumber'.txt inside the output folder.
//Each line has a seek of 20.
func writeData(fileNumber int, buff []line) {
	fmt.Println("Writing Data...")
	//Sorting
	sort.Slice(buff, func(p, q int) bool {
		return buff[p].tail < buff[q].tail
	})
	//Create file.
	file, err := os.OpenFile("./"+tableFolder+"/"+strconv.Itoa(fileNumber)+".txt", os.O_WRONLY|os.O_CREATE, 0644)
	if err != nil {
		panic(err)
	}
	//Write all lines
	writeSeek := int64(0)
	for _, line := range buff {
		file.WriteString(line.head + endToken)
		writeSeek += 10
		file.Seek(writeSeek, 0)
		file.WriteString(line.tail + endLine)
		writeSeek += 10
		file.Seek(writeSeek, 0)
	}
	wg.Done()
}

//Generates a random password using the charSet of size 'pwSize'
func randomPassWord() []byte {
	pw := make([]byte, pwSize)
	for i := range pw {
		pw[i] = charSet[rand.Intn(62)]
	}
	return pw
}
