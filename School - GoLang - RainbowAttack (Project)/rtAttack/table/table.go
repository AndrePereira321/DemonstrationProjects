package table

import (
	"crypto/sha256"
	"fmt"
	"os"
	"sync"
)

//Struct used to parse one line of the file.
type lineStruct struct {
	head string
	tail string
}

const charSet = "azertyuiopqsdfghjklmwxcvbnAZERTYUIOPQSDFGHJKLMWXCVBN1234567890"

//Defines the size of the pw to realise the attack.
//Can be modified (MAX = 8)
const pwSize = 6

//Number of threads executed simultaning to process 'possibleTails'.
//Can be modified (Must be > 1)
const tryCount = 1000

//Size of each line in the file.
const lineSize = 20

//Used access file by single thread.
var mutex = &sync.Mutex{}

//Used to wait for file reading results.
var wg = &sync.WaitGroup{}

//Reading global vars to avoid passing too many arguments to threads.
var (
	chainLength int
	fileSize    int64
	inputHash   *[32]byte
)

//Main public function to search if the hash appears in one chain(line)
//of the given file. It calculates a 'tryCount' number of possible tails into different
//routines and checks the existence of thoose tails into the file. It it exists,
//it recreates all the chain to try to find the password corresponding the hash.
func FindPassWord(hash *[32]byte, chainSize int, rainbowTable *os.File) string {
	var runningThreads, currentCol int
	var result string
	chainLength = chainSize
	inputHash = hash
	fileSize, _ = rainbowTable.Seek(0, 2)
	currentCol = chainLength - 1
	//Channel used by different Routines - Producer: makeChain |Â Consummer: verifyTails
	possibleTails := make(chan string, tryCount)
	for currentCol >= 0 {
		for runningThreads = 0; runningThreads < tryCount && currentCol >= 0; runningThreads++ {
			go makeChain(currentCol, possibleTails)
			currentCol--
		}
		result = verifyTails(rainbowTable, possibleTails, runningThreads)
		if result != "" {
			return result
		}

	}
	return ""
}

//Recreates a chain starting in the given startCol until chainLength
//Sends the result tail to the channel possibleTails.
func makeChain(startCol int, possibleTails chan string) {
	var i, j int
	var currentHash [32]byte
	pw := make([]byte, pwSize)
	currentHash = *inputHash
	for i = startCol; i < chainLength; i++ {
		//Reduce function
		for j = 0; j < pwSize; j++ {
			pw[j] = charSet[currentHash[(j+i)%32]%62]
		}
		currentHash = sha256.Sum256(pw)
	}
	possibleTails <- string(pw)
}

//Receives the possible tails generated by makeChain into the channel
//and searchs for the results into the file into separeted routines.
func verifyTails(file *os.File, possibleTails chan string, runningThreads int) string {
	var possibleTail string
	result := make(chan string, tryCount)
	for i := 0; i < runningThreads; i++ {
		possibleTail = <-possibleTails
		wg.Add(1)
		go binarySearch(file, possibleTail, result)
	}
	fmt.Println("Waiting File Reading")
	//Wait for file looking.
	wg.Wait()
	select {
	case passWord, ok := <-result:
		if ok {
			return passWord
		}
		//No routine binarySearch have writed data into channel (no results found).
		return ""
	default:
		//Error channel closed
		return ""
	}
}

//Searchs for the possible tail into the file. If the tail is found it
//will recreate the chain and try to retrieve the password corresponding the hash.
//The repetitions of tails are allowed to not reduce the succes rate.
func binarySearch(file *os.File, possibleTail string, channel chan string) {
	var line lineStruct
	//Zone to read the lines for the thread
	lineParser := make([]byte, lineSize)
	left := int64(1)
	right := fileSize/lineSize - 1
	m := left + (right-left)/2
	for left <= right {
		line = readLine(file, m, lineParser)
		if possibleTail == line.tail {
			result := retrievePotentialPassword(line.head)
			if result != "" {
				channel <- result
				wg.Done()
				return
			}
			//Check repetitions up
			result = verifyRepetitions(m, -1, file, possibleTail)
			if result != "" {
				channel <- result
				wg.Done()
				return
			}
			//Check repetitions down
			result = verifyRepetitions(m, 1, file, possibleTail)
			if result != "" {
				channel <- result
				wg.Done()
				return
			}
			//No pw found with the corresponding tail.
			wg.Done()
			return
		} else if possibleTail > line.tail {
			left = m + 1
		} else {
			right = m - 1
		}
		m = left + (right-left)/2
	}
	//No tail found
	wg.Done()
	return
}

//Parses the line 'm' of the file into a lineStruct.
//Can be used by different routines.
func readLine(file *os.File, m int64, lineParser []byte) lineStruct {
	var line lineStruct
	mutex.Lock()
	{
		file.Seek(m*lineSize, 0)
		file.Read(lineParser)
	}
	mutex.Unlock()
	i := lineSize / 2
	for lineParser[i] != 0 {
		i++
	}
	line.tail = string(lineParser[lineSize/2 : i])
	line.head = string(lineParser[0 : i-(lineSize/2)])
	return line
}

//Checks the repetitions of the 'possibleTail' into the sorted file of the given line 'm'
//'delta' represents the direction UP or DOWN
func verifyRepetitions(m, delta int64, file *os.File, possibleTail string) string {
	var line lineStruct
	lineParser := make([]byte, lineSize)
	line = readLine(file, m, lineParser)
	for k := delta; line.tail == possibleTail; k += delta {
		line = readLine(file, m+k, lineParser)
		if possibleTail == line.tail {
			result := retrievePotentialPassword(line.head)
			if result != "" {
				return result
			}
		}
	}
	return ""
}

//Recreates the chain of size 'chainLength' starting at 'head'.
//If the 'inputHash' appears in that chain it returns the corresponding passWord.
func retrievePotentialPassword(head string) string {
	var i, j int
	var currentHash [32]byte
	currentPw := []byte(head)
	for i = 0; i < chainLength; i++ {
		currentHash = sha256.Sum256(currentPw)
		if currentHash == *inputHash {
			return string(currentPw)
		}
		//Reduce function
		for j = 0; j < pwSize; j++ {
			currentPw[j] = charSet[currentHash[(j+i)%32]%62]
		}
	}
	return ""
}
